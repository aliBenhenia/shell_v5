# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ruby-prof` gem.
# Please instead update this file by running `bin/tapioca gem ruby-prof`.

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files
Rack::GET = T.let(T.unsafe(nil), String)
Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_ERROR = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RESPONSE_FINISHED = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)
Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

class Rack::RubyProf
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  private

  def paths_match?(path, paths); end
  def print(data, path); end
  def profiling_options; end
  def should_profile?(path); end
end

Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)
Rack::VERSION = T.let(T.unsafe(nil), Array)
Rack::VERSION_STRING = T.let(T.unsafe(nil), String)

module RubyProf
  class << self
    def ensure_not_running!; end
    def ensure_running!; end
    def exclude_threads; end
    def exclude_threads=(value); end
    def figure_measure_mode; end
    def measure_mode; end
    def measure_mode=(value); end
    def pause; end
    def profile(options = T.unsafe(nil), &block); end
    def resume; end
    def running?; end
    def start; end
    def start_script(script); end
    def stop; end
  end
end

RubyProf::ALLOCATIONS = T.let(T.unsafe(nil), Integer)

class RubyProf::AbstractPrinter
  def initialize(result); end

  def filter_by; end
  def max_percent; end
  def method_href(thread, method); end
  def method_location(method); end
  def min_percent; end
  def open_asset(file); end
  def print(output = T.unsafe(nil), options = T.unsafe(nil)); end
  def print_column_headers; end
  def print_footer(thread); end
  def print_header(thread); end
  def print_thread(thread); end
  def print_threads; end
  def setup_options(options = T.unsafe(nil)); end
  def sort_method; end
  def time_format; end

  class << self
    def needs_dir?; end
  end
end

class RubyProf::AggregateCallTree < ::RubyProf::CallTree; end

class RubyProf::Allocation
  def _dump_data; end
  def _load_data(_arg0); end
  def count; end
  def klass_flags; end
  def klass_name; end
  def line; end
  def memory; end
  def source_file; end
end

RubyProf::CLOCKS_PER_SEC = T.let(T.unsafe(nil), Integer)

class RubyProf::CallInfoPrinter < ::RubyProf::AbstractPrinter
  private

  def print_footer(thread); end
  def print_header(thread); end
  def print_methods(thread); end
end

RubyProf::CallInfoPrinter::TIME_WIDTH = T.let(T.unsafe(nil), Integer)

class RubyProf::CallStackPrinter < ::RubyProf::AbstractPrinter
  include ::ERB::Util

  def application; end
  def arguments; end
  def base64_image; end
  def color(p); end
  def dump(ci); end
  def expansion; end
  def graph_link(call_tree); end
  def link(method, recursive); end
  def method_href(method); end
  def name(call_tree); end
  def print(output = T.unsafe(nil), options = T.unsafe(nil)); end
  def print_stack(output, visited, call_tree, parent_time); end
  def setup_options(options); end
  def sum(a); end
  def template; end
  def threshold; end
  def title; end
  def total_time(call_trees); end
end

class RubyProf::CallTree
  def <=>(other); end
  def _dump_data; end
  def _load_data(_arg0); end
  def called; end
  def children; end
  def children_time; end
  def depth; end
  def inspect; end
  def line; end
  def measurement; end
  def parent; end
  def self_time; end
  def source_file; end
  def target; end
  def to_s; end
  def total_time; end
  def wait_time; end
end

class RubyProf::CallTreePrinter < ::RubyProf::AbstractPrinter
  def base_name; end
  def calltree_name(method_info); end
  def convert(value); end
  def determine_event_specification_and_value_scale; end
  def file(method); end
  def file_name_for_thread(thread); end
  def file_path_for_thread(thread); end
  def path; end
  def print(options = T.unsafe(nil)); end
  def print_headers(output, thread); end
  def print_method(output, method); end
  def print_thread(thread); end
  def print_threads; end
  def remove_subsidiary_files_from_previous_profile_runs; end
  def validate_print_params(options); end

  class << self
    def needs_dir?; end
  end
end

class RubyProf::CallTreeVisitor
  def initialize(call_tree); end

  def visit(&block); end

  private

  def visit_call_tree(call_tree, &block); end
end

class RubyProf::CallTrees
  def _dump_data; end
  def _load_data(_arg0); end
  def call_trees; end
  def callees; end
  def callers; end
  def min_depth; end
end

class RubyProf::DotPrinter < ::RubyProf::AbstractPrinter
  def initialize(result); end

  def print(output = T.unsafe(nil), options = T.unsafe(nil)); end

  private

  def dot_id(subject); end
  def mode_name; end
  def print_classes(thread); end
  def print_edges(total_time, method); end
  def print_thread(thread); end
  def print_threads; end
  def puts(str); end
end

RubyProf::DotPrinter::CLASS_COLOR = T.let(T.unsafe(nil), String)
RubyProf::DotPrinter::EDGE_COLOR = T.let(T.unsafe(nil), String)

module RubyProf::ExcludeCommonMethods
  class << self
    def apply!(profile); end
    def exclude_enumerable(profile, mod, *method_or_methods); end
    def exclude_methods(profile, mod, *method_or_methods); end
    def exclude_singleton_methods(profile, mod, *method_or_methods); end
  end
end

RubyProf::ExcludeCommonMethods::ENUMERABLE_NAMES = T.let(T.unsafe(nil), Array)

class RubyProf::FlatPrinter < ::RubyProf::AbstractPrinter
  def sort_method; end

  private

  def print_column_headers; end
  def print_methods(thread); end
end

class RubyProf::GraphHtmlPrinter < ::RubyProf::AbstractPrinter
  include ::ERB::Util

  def create_link(thread, overall_time, method); end
  def file_link(path, linenum); end
  def method_href(thread, method); end
  def print(output = T.unsafe(nil), options = T.unsafe(nil)); end
  def setup_options(options); end
  def template; end
end

class RubyProf::GraphPrinter < ::RubyProf::AbstractPrinter
  private

  def print_children(method); end
  def print_header(thread); end
  def print_methods(thread); end
  def print_parents(thread, method); end
  def sort_method; end
end

RubyProf::GraphPrinter::CALL_WIDTH = T.let(T.unsafe(nil), Integer)
RubyProf::GraphPrinter::PERCENTAGE_WIDTH = T.let(T.unsafe(nil), Integer)
RubyProf::GraphPrinter::TIME_WIDTH = T.let(T.unsafe(nil), Integer)
RubyProf::MEMORY = T.let(T.unsafe(nil), Integer)
module RubyProf::Measure; end
class RubyProf::Measure::Allocations; end
class RubyProf::Measure::ProcessTime; end
class RubyProf::Measure::WallTime; end

class RubyProf::Measurement
  def _dump_data; end
  def _load_data(_arg0); end
  def called; end
  def called=(_arg0); end
  def children_time; end
  def inspect; end
  def self_time; end
  def to_s; end
  def total_time; end
  def wait_time; end
end

class RubyProf::MethodInfo
  include ::Comparable

  def <=>(other); end
  def _dump_data; end
  def _load_data(_arg0); end
  def allocations; end
  def call_trees; end
  def called; end
  def children_time; end
  def full_name; end
  def klass_flags; end
  def klass_name; end
  def line; end
  def measurement; end
  def method_name; end
  def recursive?; end
  def self_time; end
  def source_file; end
  def to_s; end
  def total_time; end
  def wait_time; end
end

class RubyProf::MultiPrinter
  def initialize(result, printers = T.unsafe(nil)); end

  def call_info_report; end
  def dot_report; end
  def flat_report; end
  def graph_html_report; end
  def graph_report; end
  def print(options); end
  def print_to_call_info(options); end
  def print_to_dot(options); end
  def print_to_flat(options); end
  def print_to_graph(options); end
  def print_to_graph_html(options); end
  def print_to_stack(options); end
  def print_to_tree(options); end
  def stack_report; end
  def tree_report; end
  def validate_print_params(options); end

  class << self
    def needs_dir?; end
  end
end

RubyProf::PROCESS_TIME = T.let(T.unsafe(nil), Integer)

class RubyProf::Profile
  def initialize(*_arg0); end

  def _dump_data; end
  def _load_data(_arg0); end
  def exclude_common_methods!; end
  def exclude_method!(_arg0, _arg1); end
  def exclude_methods!(mod, *method_or_methods); end
  def exclude_singleton_methods!(mod, *method_or_methods); end
  def measure_mode; end
  def measure_mode_string; end
  def pause; end
  def paused?; end
  def profile; end
  def resume; end
  def running?; end
  def start; end
  def stop; end
  def threads; end
  def track_allocations?; end

  class << self
    def profile(*_arg0); end
  end
end

class RubyProf::Thread
  def _dump_data; end
  def _load_data(_arg0); end
  def call_tree; end
  def fiber_id; end
  def id; end
  def methods; end
  def total_time; end
  def wait_time; end
end

RubyProf::VERSION = T.let(T.unsafe(nil), String)
RubyProf::WALL_TIME = T.let(T.unsafe(nil), Integer)
